<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="31" skipped="2" tests="158" time="90.938" timestamp="2025-05-04T21:16:59.247835-04:00" hostname="Eddies-Mac-mini.local"><testcase classname="tests.test_cli.TestParseArgs" name="test_parse_args_defaults" time="0.001" /><testcase classname="tests.test_cli.TestParseArgs" name="test_parse_args_with_values" time="0.000" /><testcase classname="tests.test_cli.TestFetchContent" name="test_fetch_content_http_error" time="0.001"><failure message="SystemExit: 2">url = 'https://example.com', timeout = 30, user_agent = None, encoding = None
verbose = False, continue_on_error = False, error_format = 'text'

    @with_error_boundary(ErrorType.NETWORK, "fetch_content")
    def fetch_content(url: str, timeout: int = 30, user_agent: Optional[str] = None,
                     encoding: Optional[str] = None, verbose: bool = False,
                     continue_on_error: bool = False, error_format: str = "text") -&gt; Union[str, bytes]:
        """Fetch content from a URL.
    
        Args:
            url: URL to fetch
            timeout: Timeout in seconds
            user_agent: User agent string
            encoding: Optional encoding to use. If specified, content is returned as bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Content as string or bytes
    
        Raises:
            requests.RequestException: If there's a problem fetching the URL
        """
        with ErrorBoundary("fetch_content", ErrorType.NETWORK,
                          verbose, continue_on_error, error_format) as eb:
            eb.add_context("url", url)
            eb.add_context("timeout", timeout)
    
            headers = {}
            if user_agent:
                headers["User-Agent"] = user_agent
                eb.add_context("user_agent", user_agent)
    
            if encoding:
                eb.add_context("encoding", encoding)
    
            response = requests.get(url, headers=headers, timeout=timeout)
&gt;           response.raise_for_status()

cli/main.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Mock name='get().raise_for_status' id='4426997712'&gt;, args = ()
kwargs = {}, effect = HTTPError('404 Not Found')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               requests.exceptions.HTTPError: 404 Not Found

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1183: HTTPError

During handling of the above exception, another exception occurred:

args = ('https://example.com',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x107df3390&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:123: in fetch_content
    with ErrorBoundary("fetch_content", ErrorType.NETWORK,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x107de9dd0&gt;
exception = HTTPError('404 Not Found')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: 404 Not Found

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestFetchContent testMethod=test_fetch_content_http_error&gt;
mock_get = &lt;MagicMock name='get' id='4403250448'&gt;

    @mock.patch('cli.main.requests.get')
    def test_fetch_content_http_error(self, mock_get):
        """Test fetching content with HTTP error."""
        # Set up mock response to raise HTTP error
        mock_response = mock.Mock()
        mock_response.raise_for_status.side_effect = requests.HTTPError('404 Not Found')
        mock_get.return_value = mock_response
    
        # Test HTTP error
&gt;       content, error = fetch_content('https://example.com')

tests/test_cli.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('https://example.com',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x107df3390&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 2

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestFetchContent" name="test_fetch_content_network_error" time="0.000"><failure message="SystemExit: 2">url = 'https://example.com', timeout = 30, user_agent = None, encoding = None
verbose = False, continue_on_error = False, error_format = 'text'

    @with_error_boundary(ErrorType.NETWORK, "fetch_content")
    def fetch_content(url: str, timeout: int = 30, user_agent: Optional[str] = None,
                     encoding: Optional[str] = None, verbose: bool = False,
                     continue_on_error: bool = False, error_format: str = "text") -&gt; Union[str, bytes]:
        """Fetch content from a URL.
    
        Args:
            url: URL to fetch
            timeout: Timeout in seconds
            user_agent: User agent string
            encoding: Optional encoding to use. If specified, content is returned as bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Content as string or bytes
    
        Raises:
            requests.RequestException: If there's a problem fetching the URL
        """
        with ErrorBoundary("fetch_content", ErrorType.NETWORK,
                          verbose, continue_on_error, error_format) as eb:
            eb.add_context("url", url)
            eb.add_context("timeout", timeout)
    
            headers = {}
            if user_agent:
                headers["User-Agent"] = user_agent
                eb.add_context("user_agent", user_agent)
    
            if encoding:
                eb.add_context("encoding", encoding)
    
&gt;           response = requests.get(url, headers=headers, timeout=timeout)

cli/main.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='get' id='4577936016'&gt;, args = ('https://example.com',)
kwargs = {'headers': {}, 'timeout': 30}
effect = RequestException('Network error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               requests.exceptions.RequestException: Network error

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1183: RequestException

During handling of the above exception, another exception occurred:

args = ('https://example.com',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x110ddd850&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:123: in fetch_content
    with ErrorBoundary("fetch_content", ErrorType.NETWORK,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x110dd2c10&gt;
exception = RequestException('Network error')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: Network error

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestFetchContent testMethod=test_fetch_content_network_error&gt;
mock_get = &lt;MagicMock name='get' id='4577936016'&gt;

    @mock.patch('cli.main.requests.get')
    def test_fetch_content_network_error(self, mock_get):
        """Test fetching content with network error."""
        # Set up mock to raise an exception
        mock_get.side_effect = requests.RequestException('Network error')
    
        # Test network error
&gt;       content, error = fetch_content('https://example.com')

tests/test_cli.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('https://example.com',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x110ddd850&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 2

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestFetchContent" name="test_fetch_content_success" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestFetchContent testMethod=test_fetch_content_success&gt;
mock_get = &lt;MagicMock name='get' id='4578405712'&gt;

    @mock.patch('cli.main.requests.get')
    def test_fetch_content_success(self, mock_get):
        """Test fetching content successfully."""
        # Set up mock response
        mock_response = mock.Mock()
        mock_response.text = '&lt;html&gt;&lt;body&gt;&lt;p&gt;Test content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'
        mock_response.content = b'&lt;html&gt;&lt;body&gt;&lt;p&gt;Test content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Test with default encoding (returns text)
&gt;       content, error = fetch_content('https://example.com')
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:110: ValueError</failure></testcase><testcase classname="tests.test_cli.TestFetchContent" name="test_fetch_content_with_user_agent" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestFetchContent testMethod=test_fetch_content_with_user_agent&gt;
mock_get = &lt;MagicMock name='get' id='4426835856'&gt;

    @mock.patch('cli.main.requests.get')
    def test_fetch_content_with_user_agent(self, mock_get):
        """Test fetching content with a user agent."""
        # Set up mock response
        mock_response = mock.Mock()
        mock_response.text = '&lt;html&gt;&lt;body&gt;&lt;p&gt;Test content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Test with user agent
&gt;       content, error = fetch_content(
            'https://example.com',
            user_agent='Test User Agent'
        )
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:141: ValueError</failure></testcase><testcase classname="tests.test_cli.TestReadFile" name="test_read_file_binary_mode" time="0.001"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestReadFile testMethod=test_read_file_binary_mode&gt;

    def test_read_file_binary_mode(self):
        """Test reading file in binary mode."""
        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as f:
            f.write(b'&lt;html&gt;&lt;body&gt;&lt;p&gt;Test content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;')
            temp_file = f.name
    
        try:
            # Read file in binary mode
&gt;           content, error = read_file(temp_file, encoding='utf-8')
E           ValueError: too many values to unpack (expected 2)

tests/test_cli.py:214: ValueError</failure></testcase><testcase classname="tests.test_cli.TestReadFile" name="test_read_file_not_found" time="0.000"><failure message="SystemExit: 1">file_path = 'non_existent_file.html', encoding = None, verbose = False
continue_on_error = False, error_format = 'text'

    @with_error_boundary(ErrorType.INPUT, "read_file")
    def read_file(file_path: str, encoding: Optional[str] = None, verbose: bool = False,
                 continue_on_error: bool = False, error_format: str = "text") -&gt; Union[str, bytes]:
        """Read content from a file.
    
        Args:
            file_path: Path to the file
            encoding: Optional encoding to use. If specified, file is read in binary mode
                     and returned as bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Content as string or bytes
    
        Raises:
            FileNotFoundError: If the file does not exist
            PermissionError: If permission is denied for the file
            IOError: If there's a problem reading the file
        """
        with ErrorBoundary("read_file", ErrorType.INPUT,
                          verbose, continue_on_error, error_format) as eb:
            eb.add_context("file_path", file_path)
            if encoding:
                eb.add_context("encoding", encoding)
    
            if not Path(file_path).exists():
&gt;               raise FileNotFoundError(f"File not found: {file_path}")
E               FileNotFoundError: File not found: non_existent_file.html

cli/main.py:175: FileNotFoundError

During handling of the above exception, another exception occurred:

args = ('non_existent_file.html',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x110998650&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:168: in read_file
    with ErrorBoundary("read_file", ErrorType.INPUT,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x1109986d0&gt;
exception = FileNotFoundError('File not found: non_existent_file.html')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: File not found: non_existent_file.html

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestReadFile testMethod=test_read_file_not_found&gt;

    def test_read_file_not_found(self):
        """Test reading non-existent file."""
        # Read non-existent file
&gt;       content, error = read_file('non_existent_file.html')

tests/test_cli.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('non_existent_file.html',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x110998650&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 1

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestReadFile" name="test_read_file_text_mode" time="0.001"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestReadFile testMethod=test_read_file_text_mode&gt;

    def test_read_file_text_mode(self):
        """Test reading file in text mode (default)."""
        with tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8') as f:
            f.write('&lt;html&gt;&lt;body&gt;&lt;p&gt;Test content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;')
            temp_file = f.name
    
        try:
            # Read file in text mode
&gt;           content, error = read_file(temp_file)
E           ValueError: too many values to unpack (expected 2)

tests/test_cli.py:199: ValueError</failure></testcase><testcase classname="tests.test_cli.TestReadStdin" name="test_read_stdin_binary_mode" time="0.001"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestReadStdin testMethod=test_read_stdin_binary_mode&gt;
mock_stdin = &lt;MagicMock name='stdin' id='4392154448'&gt;

    @mock.patch('sys.stdin')
    def test_read_stdin_binary_mode(self, mock_stdin):
        """Test reading from stdin in binary mode."""
        # Set up mock stdin
        mock_stdin.isatty.return_value = False
        mock_stdin.buffer.read.return_value = b'binary_content'
    
        # Read from stdin in binary mode
&gt;       content, error = read_stdin(encoding='utf-8')
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:252: ValueError</failure></testcase><testcase classname="tests.test_cli.TestReadStdin" name="test_read_stdin_interactive" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestReadStdin testMethod=test_read_stdin_interactive&gt;
mock_stdin = &lt;MagicMock name='stdin' id='4426956304'&gt;

    @mock.patch('sys.stdin')
    def test_read_stdin_interactive(self, mock_stdin):
        """Test reading from stdin in interactive mode."""
        # Set up mock stdin for interactive mode
        mock_stdin.isatty.return_value = True
        mock_stdin.read.side_effect = ['user input', '']
    
        # Read from stdin in interactive mode
        with mock.patch('sys.stderr', new_callable=io.StringIO):
&gt;           content, error = read_stdin()
E           ValueError: too many values to unpack (expected 2)

tests/test_cli.py:265: ValueError</failure></testcase><testcase classname="tests.test_cli.TestReadStdin" name="test_read_stdin_io_error" time="0.001"><failure message="SystemExit: 1">encoding = None, verbose = False, continue_on_error = False
error_format = 'text'

    @with_error_boundary(ErrorType.INPUT, "read_stdin")
    def read_stdin(encoding: Optional[str] = None, verbose: bool = False,
                  continue_on_error: bool = False, error_format: str = "text") -&gt; Union[str, bytes]:
        """Read content from stdin with improved handling.
    
        Detects if stdin is connected to a terminal and provides appropriate
        feedback. Reads in chunks to avoid memory issues with large inputs.
    
        Args:
            encoding: Optional encoding to use. If specified, stdin is read in binary mode
                     and returned as bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Content as string or bytes
    
        Raises:
            KeyboardInterrupt: If the user interrupts input
            IOError: If there's a problem reading from stdin
        """
        with ErrorBoundary("read_stdin", ErrorType.INPUT,
                          verbose, continue_on_error, error_format) as eb:
            if encoding:
                eb.add_context("encoding", encoding)
    
            # Check if stdin is connected to a terminal
            is_terminal = sys.stdin.isatty()
            eb.add_context("is_terminal", is_terminal)
    
            if is_terminal:
                print("Reading from stdin. Enter HTML content and press Ctrl+D (Unix) or Ctrl+Z (Windows) when done:", file=sys.stderr)
    
            if encoding:
                # Read in binary mode
                stdin_bytes = sys.stdin.buffer.read()
                return stdin_bytes
            else:
                # Read with a sensible chunk size to avoid memory issues with very large inputs
                chunks = []
                while True:
&gt;                   chunk = sys.stdin.read(4096)  # Read in 4KB chunks

cli/main.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='stdin.read' id='4427032848'&gt;, args = (4096,)
kwargs = {}, effect = OSError('IO error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               OSError: IO error

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1183: OSError

During handling of the above exception, another exception occurred:

args = (), kwargs = {}, verbose = False, continue_on_error = False
error_format = 'text', eb = &lt;cli.errors.ErrorBoundary object at 0x110c6d410&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:209: in read_stdin
    with ErrorBoundary("read_stdin", ErrorType.INPUT,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x107dc4210&gt;
exception = OSError('IO error')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: IO error

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestReadStdin testMethod=test_read_stdin_io_error&gt;
mock_stdin = &lt;MagicMock name='stdin' id='4576433040'&gt;

    @mock.patch('sys.stdin')
    def test_read_stdin_io_error(self, mock_stdin):
        """Test IO error while reading from stdin."""
        # Set up mock to raise IOError
        mock_stdin.isatty.return_value = False
        mock_stdin.read.side_effect = IOError('IO error')
    
        # Test IO error
&gt;       content, error = read_stdin()

tests/test_cli.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (), kwargs = {}, verbose = False, continue_on_error = False
error_format = 'text', eb = &lt;cli.errors.ErrorBoundary object at 0x110c6d410&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 1

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestReadStdin" name="test_read_stdin_keyboard_interrupt" time="0.001"><failure message="SystemExit: 1">encoding = None, verbose = False, continue_on_error = False
error_format = 'text'

    @with_error_boundary(ErrorType.INPUT, "read_stdin")
    def read_stdin(encoding: Optional[str] = None, verbose: bool = False,
                  continue_on_error: bool = False, error_format: str = "text") -&gt; Union[str, bytes]:
        """Read content from stdin with improved handling.
    
        Detects if stdin is connected to a terminal and provides appropriate
        feedback. Reads in chunks to avoid memory issues with large inputs.
    
        Args:
            encoding: Optional encoding to use. If specified, stdin is read in binary mode
                     and returned as bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Content as string or bytes
    
        Raises:
            KeyboardInterrupt: If the user interrupts input
            IOError: If there's a problem reading from stdin
        """
        with ErrorBoundary("read_stdin", ErrorType.INPUT,
                          verbose, continue_on_error, error_format) as eb:
            if encoding:
                eb.add_context("encoding", encoding)
    
            # Check if stdin is connected to a terminal
            is_terminal = sys.stdin.isatty()
            eb.add_context("is_terminal", is_terminal)
    
            if is_terminal:
                print("Reading from stdin. Enter HTML content and press Ctrl+D (Unix) or Ctrl+Z (Windows) when done:", file=sys.stderr)
    
            if encoding:
                # Read in binary mode
                stdin_bytes = sys.stdin.buffer.read()
                return stdin_bytes
            else:
                # Read with a sensible chunk size to avoid memory issues with very large inputs
                chunks = []
                while True:
&gt;                   chunk = sys.stdin.read(4096)  # Read in 4KB chunks

cli/main.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='stdin.read' id='4578561552'&gt;, args = (4096,)
kwargs = {}, effect = KeyboardInterrupt()

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               KeyboardInterrupt

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:1183: KeyboardInterrupt

During handling of the above exception, another exception occurred:

args = (), kwargs = {}, verbose = False, continue_on_error = False
error_format = 'text', eb = &lt;cli.errors.ErrorBoundary object at 0x110e76e90&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:209: in read_stdin
    with ErrorBoundary("read_stdin", ErrorType.INPUT,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x110c2e0d0&gt;
exception = KeyboardInterrupt()

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestReadStdin testMethod=test_read_stdin_keyboard_interrupt&gt;
mock_stdin = &lt;MagicMock name='stdin' id='4578563664'&gt;

    @mock.patch('sys.stdin')
    def test_read_stdin_keyboard_interrupt(self, mock_stdin):
        """Test keyboard interrupt while reading from stdin."""
        # Set up mock to raise KeyboardInterrupt
        mock_stdin.isatty.return_value = False
        mock_stdin.read.side_effect = KeyboardInterrupt()
    
        # Test keyboard interrupt
&gt;       content, error = read_stdin()

tests/test_cli.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (), kwargs = {}, verbose = False, continue_on_error = False
error_format = 'text', eb = &lt;cli.errors.ErrorBoundary object at 0x110e76e90&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 1

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestReadStdin" name="test_read_stdin_text_mode" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestReadStdin testMethod=test_read_stdin_text_mode&gt;
mock_stdin = &lt;MagicMock name='stdin' id='4426891472'&gt;

    @mock.patch('sys.stdin')
    def test_read_stdin_text_mode(self, mock_stdin):
        """Test reading from stdin in text mode."""
        # Set up mock stdin
        mock_stdin.isatty.return_value = False
        mock_stdin.read.side_effect = ['chunk1', 'chunk2', '']
    
        # Read from stdin in text mode
&gt;       content, error = read_stdin()
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:240: ValueError</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_html_format" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_html_format&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4578468240'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_html_format(self, mock_readability_class):
        """Test processing content with HTML format."""
        # Set up mock Readability
        mock_parser = mock.Mock()
        mock_article = mock.Mock()
        mock_article.content = '&lt;div&gt;Article content&lt;/div&gt;'
        mock_article.title = 'Article Title'
        mock_parser.parse.return_value = (mock_article, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with HTML format
&gt;       content, error = process_content('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', format='html')
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:310: ValueError</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_json_format" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_json_format&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4426827216'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_json_format(self, mock_readability_class):
        """Test processing content with JSON format."""
        # Set up mock Readability with all article fields
        mock_parser = mock.Mock()
        mock_article = mock.Mock()
        mock_article.title = 'Article Title'
        mock_article.byline = 'John Doe'
        mock_article.content = '&lt;div&gt;Article content&lt;/div&gt;'
        mock_article.text_content = 'Plain text content'
        mock_article.excerpt = 'Article excerpt'
        mock_article.site_name = 'Example Site'
        mock_article.image = 'https://example.com/image.jpg'
        mock_article.favicon = 'https://example.com/favicon.ico'
        mock_article.length = 100
        mock_article.published_time = None
        mock_article.url = 'https://example.com/article'
    
        mock_parser.parse.return_value = (mock_article, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with JSON format
&gt;       content, error = process_content('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', format='json')
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:366: ValueError</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_no_content" time="0.000"><failure message="SystemExit: 3">content = '&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', url = None, format = 'html'
debug = False, encoding = None, verbose = False, continue_on_error = False
error_format = 'text'

    @with_error_boundary(ErrorType.PARSING, "process_content")
    def process_content(content: Union[str, bytes], url: Optional[str] = None, format: str = "html",
                       debug: bool = False, encoding: Optional[str] = None, verbose: bool = False,
                       continue_on_error: bool = False, error_format: str = "text") -&gt; str:
        """Process content with Readability.
    
        Args:
            content: HTML content to process (string or bytes)
            url: URL for resolving relative links
            format: Output format (html, text, json)
            debug: Enable debug output
            encoding: Optional character encoding to use when content is bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Processed content as string
    
        Raises:
            ParsingError: If there's a problem parsing the HTML
            ExtractionError: If there's a problem extracting the content
            ValueError: If the format is invalid or no content was extracted
        """
        with ErrorBoundary("process_content", ErrorType.PARSING,
                          verbose, continue_on_error, error_format) as eb:
            if url:
                eb.add_context("url", url)
            eb.add_context("format", format)
            if encoding:
                eb.add_context("encoding", encoding)
    
            if debug:
                print(f"Processing content with URL: {url}", file=sys.stderr)
                if encoding:
                    print(f"Using encoding: {encoding}", file=sys.stderr)
    
            parser = Readability(debug=debug)
            article, error = parser.parse(content, url=url, encoding=encoding)
    
            if error:
                if isinstance(error, ParsingError):
                    raise ParsingError(f"Error parsing content: {error}")
                elif isinstance(error, ExtractionError):
                    raise ExtractionError(f"Error extracting content: {error}")
                else:
                    raise ValueError(f"Error processing content: {error}")
    
            if not article:
&gt;               raise ValueError("No article content found")
E               ValueError: No article content found

cli/main.py:286: ValueError

During handling of the above exception, another exception occurred:

args = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x107dde790&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:261: in process_content
    with ErrorBoundary("process_content", ErrorType.PARSING,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x107ddf4d0&gt;
exception = ValueError('No article content found')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: No article content found

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_no_content&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4426945808'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_no_content(self, mock_readability_class):
        """Test processing content with no content found."""
        # Set up mock Readability to return no article
        mock_parser = mock.Mock()
        mock_parser.parse.return_value = (None, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with no content found
&gt;       content, error = process_content('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;')

tests/test_cli.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x107dde790&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 3

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_parser_error" time="0.000"><failure message="SystemExit: 3">content = '&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', url = None, format = 'html'
debug = False, encoding = None, verbose = False, continue_on_error = False
error_format = 'text'

    @with_error_boundary(ErrorType.PARSING, "process_content")
    def process_content(content: Union[str, bytes], url: Optional[str] = None, format: str = "html",
                       debug: bool = False, encoding: Optional[str] = None, verbose: bool = False,
                       continue_on_error: bool = False, error_format: str = "text") -&gt; str:
        """Process content with Readability.
    
        Args:
            content: HTML content to process (string or bytes)
            url: URL for resolving relative links
            format: Output format (html, text, json)
            debug: Enable debug output
            encoding: Optional character encoding to use when content is bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Processed content as string
    
        Raises:
            ParsingError: If there's a problem parsing the HTML
            ExtractionError: If there's a problem extracting the content
            ValueError: If the format is invalid or no content was extracted
        """
        with ErrorBoundary("process_content", ErrorType.PARSING,
                          verbose, continue_on_error, error_format) as eb:
            if url:
                eb.add_context("url", url)
            eb.add_context("format", format)
            if encoding:
                eb.add_context("encoding", encoding)
    
            if debug:
                print(f"Processing content with URL: {url}", file=sys.stderr)
                if encoding:
                    print(f"Using encoding: {encoding}", file=sys.stderr)
    
            parser = Readability(debug=debug)
            article, error = parser.parse(content, url=url, encoding=encoding)
    
            if error:
                if isinstance(error, ParsingError):
                    raise ParsingError(f"Error parsing content: {error}")
                elif isinstance(error, ExtractionError):
                    raise ExtractionError(f"Error extracting content: {error}")
                else:
&gt;                   raise ValueError(f"Error processing content: {error}")
E                   ValueError: Error processing content: Parser error

cli/main.py:283: ValueError

During handling of the above exception, another exception occurred:

args = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x105cadb50&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:261: in process_content
    with ErrorBoundary("process_content", ErrorType.PARSING,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x110e37010&gt;
exception = ValueError('Error processing content: Parser error')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: Error processing content: Parser error

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_parser_error&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4578306000'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_parser_error(self, mock_readability_class):
        """Test processing content with parser error."""
        # Set up mock Readability to return an error
        mock_parser = mock.Mock()
        mock_parser.parse.return_value = (None, 'Parser error')
        mock_readability_class.return_value = mock_parser
    
        # Process content with parser error
&gt;       content, error = process_content('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;')

tests/test_cli.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x105cadb50&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 3

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_text_format" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_text_format&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4576523152'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_text_format(self, mock_readability_class):
        """Test processing content with text format."""
        # Set up mock Readability
        mock_parser = mock.Mock()
        mock_article = mock.Mock()
        mock_article.text_content = 'Plain text content'
        mock_parser.parse.return_value = (mock_article, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with text format
&gt;       content, error = process_content('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', format='text')
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:338: ValueError</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_unknown_format" time="0.000"><failure message="SystemExit: 3">content = '&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', url = None, format = 'unknown'
debug = False, encoding = None, verbose = False, continue_on_error = False
error_format = 'text'

    @with_error_boundary(ErrorType.PARSING, "process_content")
    def process_content(content: Union[str, bytes], url: Optional[str] = None, format: str = "html",
                       debug: bool = False, encoding: Optional[str] = None, verbose: bool = False,
                       continue_on_error: bool = False, error_format: str = "text") -&gt; str:
        """Process content with Readability.
    
        Args:
            content: HTML content to process (string or bytes)
            url: URL for resolving relative links
            format: Output format (html, text, json)
            debug: Enable debug output
            encoding: Optional character encoding to use when content is bytes
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Returns:
            Processed content as string
    
        Raises:
            ParsingError: If there's a problem parsing the HTML
            ExtractionError: If there's a problem extracting the content
            ValueError: If the format is invalid or no content was extracted
        """
        with ErrorBoundary("process_content", ErrorType.PARSING,
                          verbose, continue_on_error, error_format) as eb:
            if url:
                eb.add_context("url", url)
            eb.add_context("format", format)
            if encoding:
                eb.add_context("encoding", encoding)
    
            if debug:
                print(f"Processing content with URL: {url}", file=sys.stderr)
                if encoding:
                    print(f"Using encoding: {encoding}", file=sys.stderr)
    
            parser = Readability(debug=debug)
            article, error = parser.parse(content, url=url, encoding=encoding)
    
            if error:
                if isinstance(error, ParsingError):
                    raise ParsingError(f"Error parsing content: {error}")
                elif isinstance(error, ExtractionError):
                    raise ExtractionError(f"Error extracting content: {error}")
                else:
                    raise ValueError(f"Error processing content: {error}")
    
            if not article:
                raise ValueError("No article content found")
    
            if format == "html":
                # Wrap the content in a proper HTML document structure with encoding declaration
                html_document = f"""&lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
        &lt;title&gt;{article.title or "Extracted Content"}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {article.content}
    &lt;/body&gt;
    &lt;/html&gt;"""
                return html_document
            elif format == "text":
                return article.text_content
            elif format == "json":
                article_dict = {
                    "title": article.title,
                    "byline": article.byline,
                    "content": article.content,
                    "text_content": article.text_content,
                    "excerpt": article.excerpt,
                    "site_name": article.site_name,
                    "image": article.image,
                    "favicon": article.favicon,
                    "length": article.length,
                    "published_time": article.published_time.isoformat() if article.published_time else None,
                    "url": article.url
                }
                return json.dumps(article_dict, indent=2)
            else:
&gt;               raise ValueError(f"Unknown format: {format}")
E               ValueError: Unknown format: unknown

cli/main.py:320: ValueError

During handling of the above exception, another exception occurred:

args = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',), kwargs = {'format': 'unknown'}
verbose = False, continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x107da83d0&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:261: in process_content
    with ErrorBoundary("process_content", ErrorType.PARSING,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x107dab910&gt;
exception = ValueError('Unknown format: unknown')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: Unknown format: unknown

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_unknown_format&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4426727632'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_unknown_format(self, mock_readability_class):
        """Test processing content with unknown format."""
        # Set up mock Readability
        mock_parser = mock.Mock()
        mock_article = mock.Mock()
        mock_parser.parse.return_value = (mock_article, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with unknown format
&gt;       content, error = process_content('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', format='unknown')

tests/test_cli.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',), kwargs = {'format': 'unknown'}
verbose = False, continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x107da83d0&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 3

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_with_debug" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_with_debug&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4577896528'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_with_debug(self, mock_readability_class):
        """Test processing content with debug enabled."""
        # Set up mock Readability
        mock_parser = mock.Mock()
        mock_article = mock.Mock()
        mock_article.content = '&lt;div&gt;Article content&lt;/div&gt;'
        mock_article.title = 'Article Title'
        mock_parser.parse.return_value = (mock_article, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with debug enabled
        with mock.patch('sys.stderr', new_callable=io.StringIO):
&gt;           content, error = process_content(
                '&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',
                url='https://example.com/article',
                format='html',
                debug=True
            )
E           ValueError: too many values to unpack (expected 2)

tests/test_cli.py:423: ValueError</failure></testcase><testcase classname="tests.test_cli.TestProcessContent" name="test_process_content_with_url" time="0.000"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_cli.TestProcessContent testMethod=test_process_content_with_url&gt;
mock_readability_class = &lt;MagicMock name='Readability' id='4578301328'&gt;

    @mock.patch('cli.main.Readability')
    def test_process_content_with_url(self, mock_readability_class):
        """Test processing content with URL."""
        # Set up mock Readability
        mock_parser = mock.Mock()
        mock_article = mock.Mock()
        mock_article.content = '&lt;div&gt;Article content&lt;/div&gt;'
        mock_article.title = 'Article Title'
        mock_parser.parse.return_value = (mock_article, None)
        mock_readability_class.return_value = mock_parser
    
        # Process content with URL
&gt;       content, error = process_content(
            '&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;',
            url='https://example.com/article',
            format='html'
        )
E       ValueError: too many values to unpack (expected 2)

tests/test_cli.py:397: ValueError</failure></testcase><testcase classname="tests.test_cli.TestWriteOutput" name="test_write_output_file_error" time="0.000"><failure message="SystemExit: 4">content = 'Test content', output_path = '/invalid/path', verbose = False
continue_on_error = False, error_format = 'text'

    @with_error_boundary(ErrorType.OUTPUT, "write_output")
    def write_output(content: str, output_path: Optional[str] = None, verbose: bool = False,
                    continue_on_error: bool = False, error_format: str = "text") -&gt; None:
        """Write content to output destination.
    
        Args:
            content: Content to write
            output_path: Path to output file, or None for stdout
            verbose: Whether to include detailed information in error messages
            continue_on_error: Whether to continue execution after an error
            error_format: Format for error messages ("text" or "json")
    
        Raises:
            IOError: If there's a problem writing to the output destination
        """
        with ErrorBoundary("write_output", ErrorType.OUTPUT,
                          verbose, continue_on_error, error_format) as eb:
            if output_path:
                eb.add_context("output_path", output_path)
                # Ensure the directory exists
                output_dir = Path(output_path).parent
                if not output_dir.exists() and str(output_dir) != '.':
&gt;                   output_dir.mkdir(parents=True, exist_ok=True)

cli/main.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/invalid'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
&gt;           os.mkdir(self, mode)
E           OSError: [Errno 30] Read-only file system: '/invalid'

../../.pyenv/versions/3.11.11/lib/python3.11/pathlib.py:1116: OSError

During handling of the above exception, another exception occurred:

args = ('Test content', '/invalid/path'), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x110c7b190&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
&gt;           with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:

cli/errors.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
cli/errors.py:135: in handle_error
    raise exception
cli/errors.py:236: in wrapper
    return func(*args, **kwargs)
cli/main.py:338: in write_output
    with ErrorBoundary("write_output", ErrorType.OUTPUT,
cli/errors.py:98: in __exit__
    self.handle_error(exc_val)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;cli.errors.ErrorBoundary object at 0x110c79090&gt;
exception = OSError(30, 'Read-only file system')

    def handle_error(self, exception: Exception) -&gt; None:
        """Handle an exception.
    
        Args:
            exception: The exception to handle
        """
        # Check if this is already an ErrorBoundaryExit - avoid re-wrapping
        if isinstance(exception, ErrorBoundaryExit):
            # Pass through the error but report it at this level too
            error_info = {
                "operation": self.operation_name,
                "error_type": exception.error_type.name,
                "error_code": exception.error_type.value,
                "message": str(exception.error_type.value),  # Use the error code as message
                "exception_type": "ErrorBoundaryExit",
            }
            self.report_error(error_info)
    
            if not self.continue_on_error:
                # Re-raise the same boundary exit for outer handlers
                raise exception
            return
    
        # Determine the most appropriate error type based on the exception
        error_type = self.error_type
        if isinstance(exception, PermissionError):
            error_type = ErrorType.PERMISSION
        elif isinstance(exception, TimeoutError):
            error_type = ErrorType.TIMEOUT
        # Add more mappings as needed
    
        # Normal exception handling
        error_info = {
            "operation": self.operation_name,
            "error_type": error_type.name,
            "error_code": error_type.value,
            "message": str(exception),
            "exception_type": exception.__class__.__name__,
        }
    
        if self.verbose:
            error_info["context"] = self.context
    
        self.report_error(error_info)
    
        if not self.continue_on_error:
            # Instead of sys.exit(), raise our custom exception
            # This allows for proper nested error boundary handling
&gt;           raise ErrorBoundaryExit(error_type, str(exception))
E           cli.errors.ErrorBoundaryExit: [Errno 30] Read-only file system: '/invalid'

cli/errors.py:163: ErrorBoundaryExit

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestWriteOutput testMethod=test_write_output_file_error&gt;

    def test_write_output_file_error(self):
        """Test writing output to file with error."""
        # Try to write to an invalid path
&gt;       success, error = write_output('Test content', '/invalid/path')

tests/test_cli.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('Test content', '/invalid/path'), kwargs = {}, verbose = False
continue_on_error = False, error_format = 'text'
eb = &lt;cli.errors.ErrorBoundary object at 0x110c7b190&gt;

    def wrapper(*args, **kwargs):
        verbose = kwargs.pop("verbose", False)
        continue_on_error = kwargs.pop("continue_on_error", False)
        error_format = kwargs.pop("error_format", "text")
    
        try:
            with ErrorBoundary(operation_name, error_type, verbose, continue_on_error, error_format) as eb:
                return func(*args, **kwargs)
        except ErrorBoundaryExit as e:
            # At the top level, convert the error boundary exit to a system exit
&gt;           sys.exit(e.error_type.value)
E           SystemExit: 4

cli/errors.py:239: SystemExit</failure></testcase><testcase classname="tests.test_cli.TestWriteOutput" name="test_write_output_to_file" time="0.000"><failure message="TypeError: cannot unpack non-iterable NoneType object">self = &lt;tests.test_cli.TestWriteOutput testMethod=test_write_output_to_file&gt;

    def test_write_output_to_file(self):
        """Test writing output to file."""
        with tempfile.NamedTemporaryFile(delete=False) as f:
            temp_file = f.name
    
        try:
            # Write output to file
&gt;           success, error = write_output('Test content', temp_file)
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_cli.py:490: TypeError</failure></testcase><testcase classname="tests.test_cli.TestWriteOutput" name="test_write_output_to_stdout" time="0.000"><failure message="TypeError: cannot unpack non-iterable NoneType object">self = &lt;tests.test_cli.TestWriteOutput testMethod=test_write_output_to_stdout&gt;

    def test_write_output_to_stdout(self):
        """Test writing output to stdout."""
        # Redirect stdout
        with mock.patch('sys.stdout', new_callable=io.StringIO) as mock_stdout:
            # Write output to stdout
&gt;           success, error = write_output('Test content')
E           TypeError: cannot unpack non-iterable NoneType object

tests/test_cli.py:510: TypeError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_file_input_success" time="0.001"><failure message="AssertionError: expected call not found.&#10;Expected: read_file('test.html', None)&#10;  Actual: read_file('test.html', encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4578999568'&gt;)&#10;&#10;pytest introspection follows:&#10;&#10;Args:&#10;assert ('test.html',) == ('test.html', None)&#10;  &#10;  Right contains one more item: None&#10;  Use -v to get more diff&#10;Kwargs:&#10;assert {'continue_on...rbose': False} == {}&#10;  &#10;  Left contains 4 more items:&#10;  {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;,&#10;   'encoding': None,&#10;   'error_format': &lt;Mock name='parse_args().error_format' id='4578999568'&gt;,&#10;   'verbose': False}&#10;  Use -v to get more diff">self = &lt;MagicMock name='read_file' id='4578986448'&gt;, args = ('test.html', None)
kwargs = {}, expected = call('test.html', None)
actual = call('test.html', encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4578999568'&gt;)
_error_message = &lt;function NonCallableMock.assert_called_with.&lt;locals&gt;._error_message at 0x110cd7060&gt;
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
&gt;           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: read_file('test.html', None)
E             Actual: read_file('test.html', encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4578999568'&gt;)

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;MagicMock name='read_file' id='4578986448'&gt;, args = ('test.html', None)
kwargs = {}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
&gt;       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: read_file('test.html', None)
E         Actual: read_file('test.html', encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4578999568'&gt;)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('test.html',) == ('test.html', None)
E         
E         Right contains one more item: None
E         Use -v to get more diff
E       Kwargs:
E       assert {'continue_on...rbose': False} == {}
E         
E         Left contains 4 more items:
E         {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;,
E          'encoding': None,
E          'error_format': &lt;Mock name='parse_args().error_format' id='4578999568'&gt;,
E          'verbose': False}
E         Use -v to get more diff

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:951: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestMain testMethod=test_main_file_input_success&gt;
mock_write_output = &lt;MagicMock name='write_output' id='4578358992'&gt;
mock_process_content = &lt;MagicMock name='process_content' id='4578350160'&gt;
mock_read_file = &lt;MagicMock name='read_file' id='4578986448'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4578988816'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.read_file')
    @mock.patch('cli.main.process_content')
    @mock.patch('cli.main.write_output')
    def test_main_file_input_success(self, mock_write_output, mock_process_content,
                                    mock_read_file, mock_parse_args):
        """Test main with file input and success."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'test.html'
        args.url = None
        args.encoding = None
        args.format = 'html'
        args.debug = False
        args.output = None
        mock_parse_args.return_value = args
    
        # Set up mock read_file
        mock_read_file.return_value = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', None)
    
        # Set up mock process_content
        mock_process_content.return_value = ('Processed content', None)
    
        # Set up mock write_output
        mock_write_output.return_value = (True, None)
    
        # Call main
        result = main()
    
        # Check that functions were called correctly
        mock_parse_args.assert_called_once()
&gt;       mock_read_file.assert_called_once_with('test.html', None)
E       AssertionError: expected call not found.
E       Expected: read_file('test.html', None)
E         Actual: read_file('test.html', encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4578999568'&gt;)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('test.html',) == ('test.html', None)
E         
E         Right contains one more item: None
E         Use -v to get more diff
E       Kwargs:
E       assert {'continue_on...rbose': False} == {}
E         
E         Left contains 4 more items:
E         {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4578999504'&gt;,
E          'encoding': None,
E          'error_format': &lt;Mock name='parse_args().error_format' id='4578999568'&gt;,
E          'verbose': False}
E         Use -v to get more diff

tests/test_cli.py:617: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_file_not_found" time="0.001"><failure message="AssertionError: 0 != 1">self = &lt;tests.test_cli.TestMain testMethod=test_main_file_not_found&gt;
mock_read_file = &lt;MagicMock name='read_file' id='4426805968'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4426793424'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.read_file')
    def test_main_file_not_found(self, mock_read_file, mock_parse_args):
        """Test main with file not found error."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'non_existent.html'
        args.url = None
        args.encoding = None
        mock_parse_args.return_value = args
    
        # Set up mock read_file to raise FileNotFoundError
        mock_read_file.side_effect = FileNotFoundError('File not found')
    
        # Call main
        with mock.patch('sys.stderr', new_callable=io.StringIO):
            result = main()
    
        # Check result
&gt;       self.assertEqual(result, EXIT_ERROR_INPUT)
E       AssertionError: 0 != 1

tests/test_cli.py:722: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_keyboard_interrupt" time="0.000"><skipped type="pytest.skip" message="This test causes actual KeyboardInterrupt that's not caught by the test framework">/Users/eddie/projects/python-readability/tests/test_cli.py:825: This test causes actual KeyboardInterrupt that's not caught by the test framework</skipped></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_network_error" time="0.001"><failure message="AssertionError: 0 != 2">self = &lt;tests.test_cli.TestMain testMethod=test_main_network_error&gt;
mock_fetch_content = &lt;MagicMock name='fetch_content' id='4403339856'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4578647696'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.fetch_content')
    def test_main_network_error(self, mock_fetch_content, mock_parse_args):
        """Test main with network error."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'https://example.com'
        args.url = None
        args.timeout = 30
        args.user_agent = None
        args.encoding = None
        mock_parse_args.return_value = args
    
        # Set up mock fetch_content to return error
        mock_fetch_content.return_value = (None, 'Network error')
    
        # Call main
        with mock.patch('sys.stderr', new_callable=io.StringIO):
            result = main()
    
        # Check result
&gt;       self.assertEqual(result, EXIT_ERROR_NETWORK)
E       AssertionError: 0 != 2

tests/test_cli.py:701: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_output_error" time="0.000"><failure message="AssertionError: 0 != 4">self = &lt;tests.test_cli.TestMain testMethod=test_main_output_error&gt;
mock_write_output = &lt;MagicMock name='write_output' id='4573610576'&gt;
mock_process_content = &lt;MagicMock name='process_content' id='4403344208'&gt;
mock_fetch_content = &lt;MagicMock name='fetch_content' id='4403333584'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4577362512'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.fetch_content')
    @mock.patch('cli.main.process_content')
    @mock.patch('cli.main.write_output')
    def test_main_output_error(self, mock_write_output, mock_process_content,
                              mock_fetch_content, mock_parse_args):
        """Test main with output error."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'https://example.com'
        args.url = None
        args.timeout = 30
        args.user_agent = None
        args.encoding = None
        args.format = 'html'
        args.debug = False
        args.output = 'output.html'
        mock_parse_args.return_value = args
    
        # Set up mock fetch_content
        mock_fetch_content.return_value = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', None)
    
        # Set up mock process_content
        mock_process_content.return_value = ('Processed content', None)
    
        # Set up mock write_output to return error
        mock_write_output.return_value = (False, 'Output error')
    
        # Call main
        with mock.patch('sys.stderr', new_callable=io.StringIO):
            result = main()
    
        # Check result
&gt;       self.assertEqual(result, EXIT_ERROR_OUTPUT)
E       AssertionError: 0 != 4

tests/test_cli.py:786: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_parsing_error" time="0.001"><failure message="AssertionError: 0 != 3">self = &lt;tests.test_cli.TestMain testMethod=test_main_parsing_error&gt;
mock_process_content = &lt;MagicMock name='process_content' id='4577861776'&gt;
mock_fetch_content = &lt;MagicMock name='fetch_content' id='4427003024'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4578563728'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.fetch_content')
    @mock.patch('cli.main.process_content')
    def test_main_parsing_error(self, mock_process_content, mock_fetch_content, mock_parse_args):
        """Test main with parsing error."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'https://example.com'
        args.url = None
        args.timeout = 30
        args.user_agent = None
        args.encoding = None
        args.format = 'html'
        args.debug = False
        mock_parse_args.return_value = args
    
        # Set up mock fetch_content
        mock_fetch_content.return_value = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', None)
    
        # Set up mock process_content to return error
        mock_process_content.return_value = (None, 'Parsing error')
    
        # Call main
        with mock.patch('sys.stderr', new_callable=io.StringIO):
            result = main()
    
        # Check result
&gt;       self.assertEqual(result, EXIT_ERROR_PARSING)
E       AssertionError: 0 != 3

tests/test_cli.py:751: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_specific_parsing_errors" time="0.001"><failure message="AssertionError: 0 != 3">self = &lt;tests.test_cli.TestMain testMethod=test_main_specific_parsing_errors&gt;
mock_process_content = &lt;MagicMock name='process_content' id='4426668432'&gt;
mock_fetch_content = &lt;MagicMock name='fetch_content' id='4426665360'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4576391248'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.fetch_content')
    @mock.patch('cli.main.process_content')
    def test_main_specific_parsing_errors(self, mock_process_content, mock_fetch_content, mock_parse_args):
        """Test main with specific parsing errors (ParsingError and ExtractionError)."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'https://example.com'
        args.url = None
        args.timeout = 30
        args.user_agent = None
        args.encoding = None
        args.format = 'html'
        args.debug = False
        mock_parse_args.return_value = args
    
        # Set up mock fetch_content
        mock_fetch_content.return_value = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', None)
    
        # Test with ParsingError
        parsing_error = ParsingError("HTML parsing failed")
        mock_process_content.return_value = (None, parsing_error)
    
        with mock.patch('sys.stderr', new_callable=io.StringIO):
            result = main()
    
&gt;       self.assertEqual(result, EXIT_ERROR_PARSING)
E       AssertionError: 0 != 3

tests/test_cli.py:814: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_stdin_input_success" time="0.001"><failure message="AssertionError: expected call not found.&#10;Expected: read_stdin(None)&#10;  Actual: read_stdin(encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577884432'&gt;)&#10;&#10;pytest introspection follows:&#10;&#10;Args:&#10;assert () == (None,)&#10;  &#10;  Right contains one more item: None&#10;  Use -v to get more diff&#10;Kwargs:&#10;assert {'continue_on...rbose': False} == {}&#10;  &#10;  Left contains 4 more items:&#10;  {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;,&#10;   'encoding': None,&#10;   'error_format': &lt;Mock name='parse_args().error_format' id='4577884432'&gt;,&#10;   'verbose': False}&#10;  Use -v to get more diff">self = &lt;MagicMock name='read_stdin' id='4426825872'&gt;, args = (None,)
kwargs = {}, expected = call(None)
actual = call(encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577884432'&gt;)
_error_message = &lt;function NonCallableMock.assert_called_with.&lt;locals&gt;._error_message at 0x110cd4ae0&gt;
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
&gt;           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: read_stdin(None)
E             Actual: read_stdin(encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577884432'&gt;)

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;MagicMock name='read_stdin' id='4426825872'&gt;, args = (None,)
kwargs = {}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
&gt;       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: read_stdin(None)
E         Actual: read_stdin(encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577884432'&gt;)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert () == (None,)
E         
E         Right contains one more item: None
E         Use -v to get more diff
E       Kwargs:
E       assert {'continue_on...rbose': False} == {}
E         
E         Left contains 4 more items:
E         {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;,
E          'encoding': None,
E          'error_format': &lt;Mock name='parse_args().error_format' id='4577884432'&gt;,
E          'verbose': False}
E         Use -v to get more diff

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:951: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestMain testMethod=test_main_stdin_input_success&gt;
mock_write_output = &lt;MagicMock name='write_output' id='4426849168'&gt;
mock_process_content = &lt;MagicMock name='process_content' id='4426850384'&gt;
mock_read_stdin = &lt;MagicMock name='read_stdin' id='4426825872'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4426834192'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.read_stdin')
    @mock.patch('cli.main.process_content')
    @mock.patch('cli.main.write_output')
    def test_main_stdin_input_success(self, mock_write_output, mock_process_content,
                                     mock_read_stdin, mock_parse_args):
        """Test main with stdin input and success."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = None
        args.url = None
        args.encoding = None
        args.format = 'html'
        args.debug = False
        args.output = None
        mock_parse_args.return_value = args
    
        # Set up mock read_stdin
        mock_read_stdin.return_value = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', None)
    
        # Set up mock process_content
        mock_process_content.return_value = ('Processed content', None)
    
        # Set up mock write_output
        mock_write_output.return_value = (True, None)
    
        # Call main
        result = main()
    
        # Check that functions were called correctly
        mock_parse_args.assert_called_once()
&gt;       mock_read_stdin.assert_called_once_with(None)
E       AssertionError: expected call not found.
E       Expected: read_stdin(None)
E         Actual: read_stdin(encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577884432'&gt;)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert () == (None,)
E         
E         Right contains one more item: None
E         Use -v to get more diff
E       Kwargs:
E       assert {'continue_on...rbose': False} == {}
E         
E         Left contains 4 more items:
E         {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4577879952'&gt;,
E          'encoding': None,
E          'error_format': &lt;Mock name='parse_args().error_format' id='4577884432'&gt;,
E          'verbose': False}
E         Use -v to get more diff

tests/test_cli.py:664: AssertionError</failure></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_unexpected_error" time="0.000"><skipped type="pytest.skip" message="This test causes actual RuntimeError that's not caught by the test framework">/Users/eddie/projects/python-readability/tests/test_cli.py:842: This test causes actual RuntimeError that's not caught by the test framework</skipped></testcase><testcase classname="tests.test_cli.TestMain" name="test_main_url_input_success" time="0.001"><failure message="AssertionError: expected call not found.&#10;Expected: fetch_content('https://example.com', 30, None, None)&#10;  Actual: fetch_content('https://example.com', timeout=30, user_agent=None, encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577889808'&gt;)&#10;&#10;pytest introspection follows:&#10;&#10;Args:&#10;assert ('https://example.com',) == ('https://exa...0, None, None)&#10;  &#10;  Right contains 3 more items, first extra item: 30&#10;  Use -v to get more diff&#10;Kwargs:&#10;assert {'continue_on...out': 30, ...} == {}&#10;  &#10;  Left contains 6 more items:&#10;  {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;,&#10;   'encoding': None,&#10;   'error_format': &lt;Mock name='parse_args().error_format' id='4577889808'&gt;,&#10;   'timeout': 30,&#10;   'user_agent': None,&#10;   'verbose': False}&#10;  Use -v to get more diff">self = &lt;MagicMock name='fetch_content' id='4578243088'&gt;
args = ('https://example.com', 30, None, None), kwargs = {}
expected = call('https://example.com', 30, None, None)
actual = call('https://example.com', timeout=30, user_agent=None, encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577889808'&gt;)
_error_message = &lt;function NonCallableMock.assert_called_with.&lt;locals&gt;._error_message at 0x110cd4720&gt;
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
&gt;           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: fetch_content('https://example.com', 30, None, None)
E             Actual: fetch_content('https://example.com', timeout=30, user_agent=None, encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577889808'&gt;)

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;MagicMock name='fetch_content' id='4578243088'&gt;
args = ('https://example.com', 30, None, None), kwargs = {}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
&gt;       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: fetch_content('https://example.com', 30, None, None)
E         Actual: fetch_content('https://example.com', timeout=30, user_agent=None, encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577889808'&gt;)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('https://example.com',) == ('https://exa...0, None, None)
E         
E         Right contains 3 more items, first extra item: 30
E         Use -v to get more diff
E       Kwargs:
E       assert {'continue_on...out': 30, ...} == {}
E         
E         Left contains 6 more items:
E         {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;,
E          'encoding': None,
E          'error_format': &lt;Mock name='parse_args().error_format' id='4577889808'&gt;,
E          'timeout': 30,
E          'user_agent': None,
E          'verbose': False}
E         Use -v to get more diff

../../.pyenv/versions/3.11.11/lib/python3.11/unittest/mock.py:951: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_cli.TestMain testMethod=test_main_url_input_success&gt;
mock_write_output = &lt;MagicMock name='write_output' id='4578234384'&gt;
mock_process_content = &lt;MagicMock name='process_content' id='4578233936'&gt;
mock_fetch_content = &lt;MagicMock name='fetch_content' id='4578243088'&gt;
mock_parse_args = &lt;MagicMock name='parse_args' id='4577889040'&gt;

    @mock.patch('cli.main.parse_args')
    @mock.patch('cli.main.fetch_content')
    @mock.patch('cli.main.process_content')
    @mock.patch('cli.main.write_output')
    def test_main_url_input_success(self, mock_write_output, mock_process_content,
                                   mock_fetch_content, mock_parse_args):
        """Test main with URL input and success."""
        # Set up mock parse_args
        args = mock.Mock()
        args.input = 'https://example.com'
        args.url = None
        args.timeout = 30
        args.user_agent = None
        args.encoding = None
        args.format = 'html'
        args.debug = False
        args.output = None
        mock_parse_args.return_value = args
    
        # Set up mock fetch_content
        mock_fetch_content.return_value = ('&lt;html&gt;&lt;body&gt;Test&lt;/body&gt;&lt;/html&gt;', None)
    
        # Set up mock process_content
        mock_process_content.return_value = ('Processed content', None)
    
        # Set up mock write_output
        mock_write_output.return_value = (True, None)
    
        # Call main
        result = main()
    
        # Check that functions were called correctly
        mock_parse_args.assert_called_once()
&gt;       mock_fetch_content.assert_called_once_with(
            'https://example.com',
            30,
            None,
            None
        )
E       AssertionError: expected call not found.
E       Expected: fetch_content('https://example.com', 30, None, None)
E         Actual: fetch_content('https://example.com', timeout=30, user_agent=None, encoding=None, verbose=False, continue_on_error=&lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;, error_format=&lt;Mock name='parse_args().error_format' id='4577889808'&gt;)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('https://example.com',) == ('https://exa...0, None, None)
E         
E         Right contains 3 more items, first extra item: 30
E         Use -v to get more diff
E       Kwargs:
E       assert {'continue_on...out': 30, ...} == {}
E         
E         Left contains 6 more items:
E         {'continue_on_error': &lt;Mock name='parse_args().continue_on_error' id='4577887376'&gt;,
E          'encoding': None,
E          'error_format': &lt;Mock name='parse_args().error_format' id='4577889808'&gt;,
E          'timeout': 30,
E          'user_agent': None,
E          'verbose': False}
E         Use -v to get more diff

tests/test_cli.py:565: AssertionError</failure></testcase><testcase classname="tests.test_errors" name="test_error_module_imports" time="0.000" /><testcase classname="tests.test_errors.TestErrorType" name="test_error_types_exist" time="0.000" /><testcase classname="tests.test_errors.TestErrorType" name="test_error_types_are_unique" time="0.000" /><testcase classname="tests.test_errors.TestErrorBoundary" name="test_normal_execution" time="0.000" /><testcase classname="tests.test_errors.TestErrorBoundary" name="test_exception_handling" time="0.000" /><testcase classname="tests.test_errors.TestErrorBoundary" name="test_continue_on_error" time="0.000" /><testcase classname="tests.test_errors.TestErrorBoundary" name="test_context_tracking" time="0.000" /><testcase classname="tests.test_errors.TestErrorBoundary" name="test_method_chaining" time="0.000" /><testcase classname="tests.test_errors.TestErrorBoundary" name="test_json_output_format" time="0.000" /><testcase classname="tests.test_errors.TestWithErrorBoundary" name="test_decorator_basic_functionality" time="0.000" /><testcase classname="tests.test_errors.TestWithErrorBoundary" name="test_decorator_with_custom_name" time="0.000" /><testcase classname="tests.test_errors.TestWithErrorBoundary" name="test_decorator_passes_options" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_file_not_found_scenario" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_file_not_found_scenario_mocked" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_network_error_scenario" time="0.006" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_network_error_scenario_mocked" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_network_error_variations[exception0-connection error]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_network_error_variations[exception1-timeout error]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_network_error_variations[exception2-too many redirects]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_network_error_variations[exception3-general error]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_file_error_variations[exception0-1]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_file_error_variations[exception1-5]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_file_error_variations[exception2-1]" time="0.000" /><testcase classname="tests.test_errors.TestRealScenarios" name="test_nested_error_boundaries" time="0.000" /><testcase classname="tests.test_readability" name="test_specific_cases[001]" time="0.096" /><testcase classname="tests.test_readability" name="test_specific_cases[002]" time="2.749" /><testcase classname="tests.test_readability" name="test_specific_cases[003-metadata-preferred]" time="0.006" /><testcase classname="tests.test_readability" name="test_specific_cases[004-metadata-space-separated-properties]" time="0.003" /><testcase classname="tests.test_readability" name="test_specific_cases[metadata-content-missing]" time="0.004" /><testcase classname="tests.test_readability" name="test_specific_cases[base-url]" time="0.011" /><testcase classname="tests.test_readability" name="test_specific_cases[base-url-base-element]" time="0.010" /><testcase classname="tests.test_readability" name="test_specific_cases[base-url-base-element-relative]" time="0.010" /><testcase classname="tests.test_readability" name="test_specific_cases[basic-tags-cleaning]" time="0.007" /><testcase classname="tests.test_readability" name="test_specific_cases[js-link-replacement]" time="0.002" /><testcase classname="tests.test_readability" name="test_specific_cases[keep-images]" time="0.634" /><testcase classname="tests.test_readability" name="test_specific_cases[missing-paragraphs]" time="0.013" /><testcase classname="tests.test_readability" name="test_specific_cases[remove-script-tags]" time="0.006" /><testcase classname="tests.test_readability" name="test_specific_cases[replace-brs]" time="0.007" /><testcase classname="tests.test_readability" name="test_specific_cases[replace-font-tags]" time="0.005" /><testcase classname="tests.test_readability" name="test_specific_cases[comment-inside-script-parsing]" time="0.005" /><testcase classname="tests.test_readability" name="test_specific_cases[svg-parsing]" time="0.008" /><testcase classname="tests.test_readability" name="test_specific_cases[hidden-nodes]" time="0.005" /><testcase classname="tests.test_readability" name="test_specific_cases[remove-aria-hidden]" time="0.005" /><testcase classname="tests.test_readability" name="test_specific_cases[normalize-spaces]" time="0.003" /><testcase classname="tests.test_readability" name="test_specific_cases[rtl-3]" time="0.003" /><testcase classname="tests.test_readability" name="test_specific_cases[rtl-4]" time="0.004" /><testcase classname="tests.test_readability" name="test_specific_cases[qq]" time="0.151" /><testcase classname="tests.test_readability" name="test_specific_cases[aclu]" time="0.053" /><testcase classname="tests.test_readability" name="test_specific_cases[aktualne]" time="0.220" /><testcase classname="tests.test_readability" name="test_specific_cases[archive-of-our-own]" time="1.795" /><testcase classname="tests.test_readability" name="test_specific_cases[ars-1]" time="0.137" /><testcase classname="tests.test_readability" name="test_specific_cases[bbc-1]" time="0.665" /><testcase classname="tests.test_readability" name="test_specific_cases[blogger]" time="0.322" /><testcase classname="tests.test_readability" name="test_specific_cases[breitbart]" time="0.304" /><testcase classname="tests.test_readability" name="test_specific_cases[ehow-2]" time="0.134" /><testcase classname="tests.test_readability" name="test_specific_cases[herald-sun-1]" time="0.100" /><testcase classname="tests.test_readability" name="test_specific_cases[medium-1]" time="0.642" /><testcase classname="tests.test_readability" name="test_specific_cases[medium-2]" time="0.101" /><testcase classname="tests.test_readability" name="test_specific_cases[mozilla-1]" time="0.196" /><testcase classname="tests.test_readability" name="test_specific_cases[nytimes-1]" time="0.317" /><testcase classname="tests.test_readability" name="test_specific_cases[wikipedia]" time="9.242" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.HTML_PARSING]" time="0.013" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.METADATA_EXTRACTION]" time="0.009" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.CONTENT_IDENTIFICATION]" time="2.870" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.CONTENT_CLEANING]" time="0.670" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.URL_HANDLING]" time="0.029" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.VISIBILITY_DETECTION]" time="0.009" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.TEXT_NORMALIZATION]" time="0.159" /><testcase classname="tests.test_readability" name="test_by_functional_area[FunctionalArea.REAL_WORLD]" time="14.285" /><testcase classname="tests.test_readability" name="test_by_criticality[Criticality.P0]" time="13.361" /><testcase classname="tests.test_readability" name="test_by_criticality[Criticality.P1]" time="0.825" /><testcase classname="tests.test_readability" name="test_by_criticality[Criticality.P2]" time="0.439" /><testcase classname="tests.test_readability" name="test_by_criticality[Criticality.P3]" time="3.498" /><testcase classname="tests.test_readability" name="test_by_test_type[TestType.BASIC]" time="2.903" /><testcase classname="tests.test_readability" name="test_by_test_type[TestType.FEATURE]" time="0.713" /><testcase classname="tests.test_readability" name="test_by_test_type[TestType.EDGE_CASE]" time="0.184" /><testcase classname="tests.test_readability" name="test_by_test_type[TestType.REAL_WORLD]" time="14.278" /><testcase classname="tests.test_readability" name="test_all_cases" time="18.115" /><testcase classname="tests.test_utils.TestIndexOf" name="test_element_exists" time="0.000" /><testcase classname="tests.test_utils.TestIndexOf" name="test_element_not_exists" time="0.000" /><testcase classname="tests.test_utils.TestIndexOf" name="test_first_occurrence" time="0.000" /><testcase classname="tests.test_utils.TestWordCount" name="test_empty_string" time="0.000" /><testcase classname="tests.test_utils.TestWordCount" name="test_multiple_spaces" time="0.000" /><testcase classname="tests.test_utils.TestWordCount" name="test_multiple_words" time="0.000" /><testcase classname="tests.test_utils.TestWordCount" name="test_newlines_and_tabs" time="0.000" /><testcase classname="tests.test_utils.TestWordCount" name="test_single_word" time="0.000" /><testcase classname="tests.test_utils.TestWordCount" name="test_special_characters" time="0.000" /><testcase classname="tests.test_utils.TestCharCount" name="test_empty_string" time="0.000" /><testcase classname="tests.test_utils.TestCharCount" name="test_simple_string" time="0.000" /><testcase classname="tests.test_utils.TestCharCount" name="test_special_characters" time="0.000" /><testcase classname="tests.test_utils.TestIsValidUrl" name="test_edge_cases" time="0.000" /><testcase classname="tests.test_utils.TestIsValidUrl" name="test_invalid_urls" time="0.000" /><testcase classname="tests.test_utils.TestIsValidUrl" name="test_valid_urls" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_absolute_path" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_absolute_url" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_data_uri" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_empty_inputs" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_exception_handling" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_hash_fragment" time="0.000" /><testcase classname="tests.test_utils.TestToAbsoluteUri" name="test_relative_path" time="0.000" /><testcase classname="tests.test_utils.TestStrOr" name="test_all_empty" time="0.000" /><testcase classname="tests.test_utils.TestStrOr" name="test_empty_args" time="0.000" /><testcase classname="tests.test_utils.TestStrOr" name="test_multiple_arguments" time="0.000" /><testcase classname="tests.test_utils.TestStrOr" name="test_non_string_values" time="0.000" /><testcase classname="tests.test_utils.TestStrOr" name="test_single_argument" time="0.000" /><testcase classname="tests.test_utils.TestListToDict" name="test_duplicate_items" time="0.000" /><testcase classname="tests.test_utils.TestListToDict" name="test_empty_list" time="0.000" /><testcase classname="tests.test_utils.TestListToDict" name="test_mixed_list" time="0.000" /><testcase classname="tests.test_utils.TestListToDict" name="test_string_list" time="0.000" /><testcase classname="tests.test_utils.TestStrFilter" name="test_complex_filter" time="0.000" /><testcase classname="tests.test_utils.TestStrFilter" name="test_empty_list" time="0.000" /><testcase classname="tests.test_utils.TestStrFilter" name="test_filter_by_content" time="0.000" /><testcase classname="tests.test_utils.TestStrFilter" name="test_filter_by_length" time="0.000" /><testcase classname="tests.test_utils.TestTrim" name="test_empty_string" time="0.000" /><testcase classname="tests.test_utils.TestTrim" name="test_internal_whitespace" time="0.000" /><testcase classname="tests.test_utils.TestTrim" name="test_leading_trailing_whitespace" time="0.000" /><testcase classname="tests.test_utils.TestTrim" name="test_mixed_whitespace" time="0.000" /><testcase classname="tests.test_utils.TestTrim" name="test_no_whitespace" time="0.000" /><testcase classname="tests.test_utils.TestNormalizeSpaces" name="test_empty_string" time="0.000" /><testcase classname="tests.test_utils.TestNormalizeSpaces" name="test_internal_whitespace" time="0.000" /><testcase classname="tests.test_utils.TestNormalizeSpaces" name="test_leading_trailing_whitespace" time="0.000" /><testcase classname="tests.test_utils.TestNormalizeSpaces" name="test_mixed_whitespace" time="0.001" /><testcase classname="tests.test_utils.TestNormalizeSpaces" name="test_no_whitespace" time="0.000" /></testsuite></testsuites>